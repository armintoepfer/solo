<!DOCTYPE html>
<html lang="en" data-theme="light">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SoLo (Sonos Local)</title>
        <link rel="stylesheet"
            href="{{ url_for('static', filename='styles.css') }}">
    </head>
    <body>
        <div class="loading-overlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading Sonos Devices...</div>
        </div>
        <div class="container">
            <h1>SoLo (Sonos Local)</h1>
            <div class="button-container">
                <button class="refresh-button"
                    onclick="window.location.reload()">Refresh Devices</button>
                <button class="theme-toggle" onclick="toggleTheme()"
                    title="Toggle theme" data-theme="light">
                    <svg class="sun-icon" viewBox="0 0 24 24" fill="none">
                        <circle cx="12" cy="12" r="4" />
                        <path
                            d="M12 3v2M12 19v2M3 12h2M19 12h2M5.6 5.6l1.4 1.4M17 17l1.4 1.4M17 7l1.4-1.4M5.6 18.4l1.4-1.4" />
                    </svg>
                    <svg class="moon-icon" viewBox="0 0 24 24" fill="none">
                        <path d="M20 19 A 9 9 0 1 1 20 3 A 7 7 0 0 0 20 19 z" />
                    </svg>
                </button>
            </div>
            <div class="devices-list">
                {% if topology %}
                {% for device in topology %}
                {% if not device.groups or
                device.groups[0].members|selectattr('is_visible')|list|length <=
                1 %}
                <div class="device-card" data-ip="{{ device.ip }}">
                    <div class="device-main">
                        <div class="device-info">
                            <div class="device-room">{{ device.room }}</div>
                            <div class="device-model">{{ device.model }}</div>
                        </div>
                        <div class="now-playing">No music playing</div>
                        <div class="track-controls">
                            <button class="track-button"
                                onclick="controlTrack('{{ device.ip }}', 'Previous')"
                                title="Previous">⏮</button>
                            <button class="play-button"
                                data-ip="{{ device.ip }}"
                                data-state="{{ device.state }}"
                                onclick="togglePlayback(this)">
                                {{ "⏸" if device.state == "PLAYING" else "▶" }}
                            </button>
                            <button class="track-button"
                                onclick="controlTrack('{{ device.ip }}', 'Next')"
                                title="Next">⏭</button>
                        </div>
                        <div class="volume-controls">
                            <div class="volume-control">
                                <button class="volume-button"
                                    onclick="controlVolume('{{ device.ip }}', 'down')">−</button>
                                <button class="volume-text"
                                    onclick="toggleMute('{{ device.ip }}', this)"
                                    title="Click to mute">{{
                                    device.volume|default(0) }}%</button>
                                <button class="volume-button"
                                    onclick="controlVolume('{{ device.ip }}', 'up')">+</button>
                            </div>
                        </div>
                    </div>
                    <div class="device-details">
                        <div class="detail-row">
                            <span class="detail-label">Name</span>
                            <span>{{ device.name }}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">IP Address</span>
                            <span>{{ device.ip }}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Hostname</span>
                            <span>{{ device.hostname }}</span>
                        </div>
                        {% if device.groups %}
                        <div class="detail-row">
                            <span class="detail-label">Groups</span>
                            <div class="groups-list">
                                {% for group in device.groups %}
                                <div class="group-info">
                                    <span>Coordinator: {{ group.coordinator
                                        }}</span>
                                    {% if group.members %}
                                    <span>Members: {{ group.members|join(', ')
                                        }}</span>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}
                        <div class="group-controls">
                            <button class="group-button leave-group"
                                onclick="leaveGroup('{{ device.ip }}')" {% if
                                not device.groups %}style="display: none;" {%
                                endif %}>Leave Group</button>
                            <button class="group-button join-group"
                                onclick="showJoinGroupDialog('{{ device.ip }}')"
                                {% if device.groups %}style="display: none;" {%
                                endif %}>Join Group</button>
                        </div>
                    </div>
                </div>
                {% endif %}
                {% endfor %}

                {% for device in topology %}
                {% if device.groups %}
                {% for group in device.groups %}
                {% set device_id = device.name.split(' - ')[-1] %}
                {% if group.members|selectattr('is_visible')|list|length > 1 and
                group.coordinator == device_id %}
                <div class="device-card" data-ip="{{ device.ip }}"
                    data-is-group="true">
                    <div class="device-main">
                        <div class="device-info">
                            <div class="device-room">{{ device.room }}
                                Group</div>
                            <div class="device-model">{{ device.model }}</div>
                        </div>
                        <div class="now-playing">No music playing</div>
                        <div class="track-controls">
                            <button class="track-button"
                                onclick="controlTrack('{{ device.ip }}', 'Previous')"
                                title="Previous">⏮</button>
                            <button class="play-button"
                                data-ip="{{ device.ip }}"
                                data-state="{{ device.state }}"
                                onclick="togglePlayback(this)">
                                {{ "⏸" if device.state == "PLAYING" else "▶" }}
                            </button>
                            <button class="track-button"
                                onclick="controlTrack('{{ device.ip }}', 'Next')"
                                title="Next">⏭</button>
                        </div>
                        <div class="volume-controls">
                            <div class="group-volume-control">
                                <button class="volume-button-normal"
                                    onclick="controlGroupVolume('{{ device.ip }}', 'down')"
                                    title="Group volume down">−</button>
                                <button class="volume-button"
                                    onclick="controlGroupVolume('{{ device.ip }}', 'mean')"
                                    title="Set group to mean volume">⊜</button>
                                <button class="volume-button-normal"
                                    onclick="controlGroupVolume('{{ device.ip }}', 'up')"
                                    title="Group volume up">+</button>
                            </div>
                        </div>
                    </div>
                    <div class="device-details expanded">
                        <div class="groups-list">
                            {% for member in group.members %}
                            {% if member.is_visible %}
                            <div class="group-info">
                                <div class="group-device"
                                    data-ip="{{ urlparse(member.location).hostname }}">
                                    <div class="device-info">
                                        <div class="device-room">{{
                                            member.zone_name }}</div>
                                        {% for d in topology %}
                                        {% if d.name.split(' - ')[-1] ==
                                        member.uuid %}
                                        <div class="device-model">{{ d.model
                                            }}</div>
                                        {% endif %}
                                        {% endfor %}
                                    </div>
                                    <div class="volume-controls">
                                        <div class="volume-control"
                                            data-ip="{{ urlparse(member.location).hostname }}">
                                            <button class="volume-button"
                                                onclick="controlVolume('{{ urlparse(member.location).hostname }}', 'down')">−</button>
                                            <button class="volume-text"
                                                onclick="toggleMute('{{ urlparse(member.location).hostname }}', this)"
                                                title="Click to mute"
                                                data-ip="{{ urlparse(member.location).hostname }}">{{
                                                member.volume|default(0)
                                                }}%</button>
                                            <button class="volume-button"
                                                onclick="controlVolume('{{ urlparse(member.location).hostname }}', 'up')">+</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {% endif %}
                            {% endfor %}
                        </div>
                    </div>
                </div>
                {% endif %}
                {% endfor %}
                {% endif %}
                {% endfor %}
                {% else %}
                <div class="no-devices">
                    <h2>No Sonos devices found</h2>
                    <p>Make sure your Sonos devices are powered on and connected
                        to the same network.</p>
                </div>
                {% endif %}
            </div>
        </div>

        <script>
        // Global state management
        const devicePollers = new Map(); // Stores polling intervals for each device
        const volumeDebounceTimers = new Map(); // Stores volume update timers

        /**
         * Handles expanding/collapsing the device card details
         * @param {Event} event - The click event
         */
        function handleCardClick(event) {
            // Don't expand if clicking on any interactive elements
            if (event.target.closest('.volume-control') ||
                event.target.closest('.track-controls') ||
                event.target.closest('button') ||
                event.target.closest('input')) {
                return;
            }

            const card = event.currentTarget;
            const details = card.querySelector('.device-details');
            const isExpanded = details.classList.toggle('expanded');
            card.classList.toggle('expanded', isExpanded);
        }

        /**
         * Updates the play/pause button state and icon
         * @param {HTMLElement} button - The play/pause button element
         * @param {string} state - The playback state ('PLAYING' or other)
         */
        function updateButtonState(button, state) {
            console.log(`Updating button state to: ${state}`);
            button.dataset.state = state;
            button.textContent = state === 'PLAYING' ? '⏸' : '▶';
        }

        /**
         * Updates the now playing text and style
         * @param {HTMLElement} nowPlaying - The now playing element
         * @param {string} text - The text to display
         * @param {boolean} isPlaying - Whether music is currently playing
         */
        function updateNowPlaying(nowPlaying, text, isPlaying) {
            console.log(`Updating now playing: text="${text}", isPlaying=${isPlaying}`);
            // Only update if the text is different or we're explicitly setting the playing state
            if (nowPlaying.textContent !== text || nowPlaying.classList.contains('playing') !== isPlaying) {
                nowPlaying.innerHTML = isPlaying ? `<span>${text}</span>` : text;
                nowPlaying.classList.toggle('playing', isPlaying);
            }
        }

        /**
         * Starts polling for device status updates
         * @param {string} ip - The device IP address
         * @param {HTMLElement} button - The play/pause button element
         */
        function startPollingDevice(ip, button) {
            console.log(`[POLL] Starting device polling for IP: ${ip}`);
            if (devicePollers.has(ip)) {
                console.log(`[POLL] Polling already active for IP: ${ip}`);
                return;
            }

            async function pollDeviceStatus() {
                console.log(`[POLL] Polling device status for IP: ${ip}`);
                try {
                    // Poll device state
                    const url = `/api/control/${ip}/GetState`;
                    console.log(`[POLL] Fetching state from ${url}`);
                    const response = await fetch(url);
                    console.log(`[POLL] Response status: ${response.status}`);

                    if (!response.ok) {
                        console.error(`[POLL] HTTP error: ${response.status}`);
                        return;
                    }

                    const contentType = response.headers.get('content-type');
                    console.log(`[POLL] Response content type: ${contentType}`);

                    if (!contentType || !contentType.includes('application/json')) {
                        console.error(`[POLL] Invalid content type: ${contentType}`);
                        return;
                    }

                    const text = await response.text();
                    console.log(`[POLL] Raw response text: ${text}`);

                    try {
                        const data = JSON.parse(text);
                        console.log(`[POLL] Parsed response data:`, data);

                        if (data.success) {
                            updateButtonState(button, data.state);
                            const deviceCard = button.closest('.device-card');
                            const nowPlaying = deviceCard.querySelector('.now-playing');

                            // Poll volume for the main device and all group members in parallel
                            const volumePromises = [];

                            // Add main device volume polling
                            volumePromises.push(updateVolumeDisplay(ip));

                            // Check if this is a group card and poll volumes for all members
                            if (deviceCard.hasAttribute('data-is-group')) {
                                const groupMembers = deviceCard.querySelectorAll('.group-device');
                                groupMembers.forEach(member => {
                                    const memberIp = member.dataset.ip;
                                    if (memberIp) {
                                        volumePromises.push(updateVolumeDisplay(memberIp));
                                    }
                                });
                            }

                            if (data.state === 'PLAYING') {
                                console.log(`[POLL] Device is playing, fetching track info`);
                                const trackResponse = await fetch(`/api/control/${ip}/GetTrackInfo`);
                                if (!trackResponse.ok) {
                                    console.error(`[POLL] Track info HTTP error: ${trackResponse.status}`);
                                    return;
                                }
                                const trackData = await trackResponse.json();
                                console.log(`[POLL] Track info response:`, trackData);
                                const trackText = trackData.success && trackData.track ? trackData.track : 'Music playing';
                                updateNowPlaying(nowPlaying, trackText, true);
                            } else {
                                console.log(`[POLL] Device is not playing (state: ${data.state})`);
                                updateNowPlaying(nowPlaying, 'No music playing', false);
                            }

                            // Wait for all volume updates to complete
                            await Promise.all(volumePromises);
                        } else {
                            console.warn(`[POLL] GetState failed:`, data.error);
                        }
                    } catch (parseError) {
                        console.error(`[POLL] JSON parse error:`, parseError);
                        console.error(`[POLL] Failed to parse:`, text);
                    }
                } catch (error) {
                    console.error('[POLL] Error polling device status:', error);
                }
            }

            // Poll immediately and then every 2 seconds
            console.log(`[POLL] Starting initial poll for IP: ${ip}`);
            pollDeviceStatus();
            const intervalId = setInterval(pollDeviceStatus, 2000);
            devicePollers.set(ip, intervalId);
            console.log(`[POLL] Polling interval set for IP: ${ip}`);
        }

        /**
         * Toggles playback state between play and pause
         * @param {HTMLElement} button - The play/pause button element
         */
        async function togglePlayback(button) {
            const ip = button.dataset.ip;
            const currentState = button.dataset.state;
            const action = currentState === 'PLAYING' ? 'Pause' : 'Play';
            console.log(`[PLAYBACK] Toggling playback for IP ${ip}: ${currentState} -> ${action}`);

            const deviceCard = button.closest('.device-card');
            const nowPlaying = deviceCard.querySelector('.now-playing');

            button.disabled = true;
            button.classList.add('loading');
            console.log(`[PLAYBACK] Button disabled and loading state added`);

            try {
                console.log(`[PLAYBACK] Sending ${action} request to /api/control/${ip}/${action}`);
                const response = await fetch(`/api/control/${ip}/${action}`);
                console.log(`[PLAYBACK] Response status: ${response.status}`);

                if (!response.ok) {
                    console.error(`[PLAYBACK] HTTP error: ${response.status}`);
                    return;
                }

                const contentType = response.headers.get('content-type');
                console.log(`[PLAYBACK] Response content type: ${contentType}`);

                if (!contentType || !contentType.includes('application/json')) {
                    console.error(`[PLAYBACK] Invalid content type: ${contentType}`);
                    return;
                }

                const text = await response.text();
                console.log(`[PLAYBACK] Raw response text: ${text}`);

                try {
                    const data = JSON.parse(text);
                    console.log(`[PLAYBACK] Parsed response data:`, data);

                    if (data.success) {
                        updateButtonState(button, data.state);
                        console.log(`[PLAYBACK] New state: ${data.state}, Track data:`, data.track);

                        if (data.state === 'PLAYING' && data.track) {
                            updateNowPlaying(nowPlaying, data.track, true);
                        } else {
                            updateNowPlaying(nowPlaying, 'No music playing', false);
                        }

                        startPollingDevice(ip, button);
                    } else {
                        console.warn(`[PLAYBACK] ${action} request failed:`, data.error);
                    }
                } catch (parseError) {
                    console.error(`[PLAYBACK] JSON parse error:`, parseError);
                    console.error(`[PLAYBACK] Failed to parse:`, text);
                }
            } catch (error) {
                console.error('[PLAYBACK] Error toggling playback:', error);
            } finally {
                button.disabled = false;
                button.classList.remove('loading');
                console.log(`[PLAYBACK] Button re-enabled and loading state removed`);
            }
        }

        /**
         * Updates the volume display for a device
         * @param {string} ip - The device IP address
         */
        async function updateVolumeDisplay(ip) {
            try {
                console.log(`[VOLUME] Fetching volume for IP: ${ip}`);
                const response = await fetch(`/api/volume/${ip}/get`);
                const data = await response.json();

                if (data.success) {
                    console.log(`[VOLUME DEBUG] Starting volume update for IP: ${ip}`);

                    // Debug: Log all volume-text elements
                    const allVolumeTexts = document.querySelectorAll('.volume-text');
                    console.log(`[VOLUME DEBUG] Total volume-text elements found: ${allVolumeTexts.length}`);
                    allVolumeTexts.forEach(el => {
                        console.log(`[VOLUME DEBUG] Found volume-text:`, {
                            'button data-ip': el.dataset.ip,
                            'parent data-ip': el.parentElement?.dataset?.ip,
                            'grandparent data-ip': el.parentElement?.parentElement?.dataset?.ip,
                            'text content': el.textContent,
                            'parent classes': el.parentElement?.className,
                            'grandparent classes': el.parentElement?.parentElement?.className
                        });
                    });

                    // Try different selector combinations
                    const directButtons = document.querySelectorAll(`.volume-text[data-ip="${ip}"]`);
                    const parentButtons = document.querySelectorAll(`.volume-control[data-ip="${ip}"] .volume-text`);
                    const groupButtons = document.querySelectorAll(`.group-device[data-ip="${ip}"] .volume-text`);

                    console.log(`[VOLUME DEBUG] Found buttons:`, {
                        'direct': directButtons.length,
                        'parent': parentButtons.length,
                        'group': groupButtons.length
                    });

                    // Combine all selectors
                    const volumeButtons = new Set([
                        ...Array.from(directButtons),
                        ...Array.from(parentButtons),
                        ...Array.from(groupButtons)
                    ]);

                    console.log(`[VOLUME DEBUG] Total unique buttons to update: ${volumeButtons.size}`);

                    if (volumeButtons.size === 0) {
                        // Try one more time with a broader selector
                        const allPossibleButtons = document.querySelectorAll(`
                            .volume-text[data-ip="${ip}"],
                            [data-ip="${ip}"] .volume-text,
                            .group-device[data-ip="${ip}"] .volume-text,
                            .volume-control[data-ip="${ip}"] .volume-text,
                            .device-card[data-ip="${ip}"] .volume-text
                        `);
                        console.log(`[VOLUME DEBUG] Last attempt found ${allPossibleButtons.length} buttons`);

                        if (allPossibleButtons.length === 0) {
                            console.warn(`[VOLUME] No volume displays found for IP ${ip}`);
                            // Log the HTML structure around where we expect the button to be
                            const groupDevices = document.querySelectorAll('.group-device');
                            console.log(`[VOLUME DEBUG] Group devices found:`, Array.from(groupDevices).map(el => ({
                                'data-ip': el.dataset.ip,
                                'innerHTML': el.innerHTML.substring(0, 100) + '...'
                            })));
                            return;
                        }
                        volumeButtons.add(...allPossibleButtons);
                    }

                    volumeButtons.forEach(button => {
                        const roomElement = button.closest('.device-info')?.querySelector('.device-room');
                        const roomName = roomElement ? roomElement.textContent.trim() : 'unknown room';
                        console.log(`[VOLUME] Updating button for ${ip} in: ${roomName}`);

                        button.textContent = `${data.volume}%`;
                        if (data.muted) {
                            button.classList.add('muted');
                            button.title = 'Click to unmute';
                        } else {
                            button.classList.remove('muted');
                            button.title = 'Click to mute';
                        }
                        console.log(`[VOLUME] Updated volume display for IP ${ip} to ${data.volume}%, muted: ${data.muted}`);
                    });
                } else {
                    console.error(`[VOLUME] Failed to get volume for IP ${ip}:`, data.error);
                }
            } catch (error) {
                console.error(`[VOLUME] Error updating volume display for IP ${ip}:`, error);
            }
        }

        /**
         * Controls the volume up/down
         * @param {string} ip - The device IP address
         * @param {string} direction - The volume direction ('up' or 'down')
         */
        async function controlVolume(ip, direction) {
            console.log(`[VOLUME] Controlling volume for IP ${ip}, direction: ${direction}`);

            // Find all volume controls for this device
            const volumeControls = document.querySelectorAll(`[data-ip="${ip}"] .volume-control, .volume-control[data-ip="${ip}"]`);

            if (!volumeControls.length) {
                console.error('[VOLUME] Could not find volume control for device:', ip);
                return;
            }

            console.log(`[VOLUME] Found ${volumeControls.length} volume controls for IP ${ip}`);

            // Check if this is a group member by looking for a parent .group-device
            const isGroupMember = Array.from(volumeControls).some(control => control.closest('.group-device'));

            if (isGroupMember) {
                // For group members, only update the specific control that was clicked
                const volumeControl = document.querySelector(`.volume-control[data-ip="${ip}"]`);
                if (!volumeControl) return;

                const buttons = volumeControl.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                });

                try {
                    const response = await fetch(`/api/volume/${ip}/${direction.toLowerCase()}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                    const data = await response.json();
                    console.log(`[VOLUME] Response:`, data);

                    if (data.success) {
                        const volumeText = volumeControl.querySelector('.volume-text');
                        if (volumeText) {
                            volumeText.textContent = `${data.volume}%`;
                            console.log(`[VOLUME] Updated volume display to ${data.volume}%`);
                        }
                    } else {
                        console.warn(`[VOLUME] Volume control failed:`, data.error);
                    }
                } catch (error) {
                    console.error('[VOLUME] Error controlling volume:', error);
                } finally {
                    buttons.forEach(btn => {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    });
                }
            } else {
                // For individual devices, update all volume controls (original behavior)
                volumeControls.forEach(control => {
                    const buttons = control.querySelectorAll('button');
                    buttons.forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                    });
                });

                try {
                    const response = await fetch(`/api/volume/${ip}/${direction.toLowerCase()}`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                    const data = await response.json();
                    console.log(`[VOLUME] Response:`, data);

                    if (data.success) {
                        volumeControls.forEach(control => {
                            const volumeText = control.querySelector('.volume-text');
                            if (volumeText) {
                                volumeText.textContent = `${data.volume}%`;
                                console.log(`[VOLUME] Updated volume display to ${data.volume}%`);
                            }
                        });
                    } else {
                        console.warn(`[VOLUME] Volume control failed:`, data.error);
                    }
                } catch (error) {
                    console.error('[VOLUME] Error controlling volume:', error);
                } finally {
                    volumeControls.forEach(control => {
                        const buttons = control.querySelectorAll('button');
                        buttons.forEach(btn => {
                            btn.disabled = false;
                            btn.style.opacity = '1';
                        });
                    });
                }
            }
        }

        /**
         * Controls track navigation (previous/next)
         * @param {string} ip - The device IP address
         * @param {string} action - The track control action ('Previous' or 'Next')
         */
        async function controlTrack(ip, action) {
            console.log(`[TRACK] Controlling track for IP ${ip}, action: ${action}`);

            const deviceCard = document.querySelector(`.device-card[data-ip="${ip}"]`);
            const buttons = deviceCard.querySelectorAll('.track-button');
            const nowPlaying = deviceCard.querySelector('.now-playing');
            const currentTrack = nowPlaying.textContent;
            const wasPlaying = nowPlaying.classList.contains('playing');

            // Disable buttons and show loading state
            buttons.forEach(btn => btn.disabled = true);
            nowPlaying.classList.add('loading');
            console.log(`[TRACK] Disabled track control buttons and added loading state`);

            try {
                console.log(`[TRACK] Sending ${action} request to /api/control/${ip}/${action}`);
                const response = await fetch(`/api/control/${ip}/${action}`);
                console.log(`[TRACK] Response status: ${response.status}`);

                if (!response.ok) {
                    console.error(`[TRACK] HTTP error: ${response.status}`);
                    updateNowPlaying(nowPlaying, currentTrack, wasPlaying);
                    return;
                }

                const contentType = response.headers.get('content-type');
                console.log(`[TRACK] Response content type: ${contentType}`);

                if (!contentType || !contentType.includes('application/json')) {
                    console.error(`[TRACK] Invalid content type: ${contentType}`);
                    updateNowPlaying(nowPlaying, currentTrack, wasPlaying);
                    return;
                }

                const text = await response.text();
                console.log(`[TRACK] Raw response text: ${text}`);

                try {
                    const data = JSON.parse(text);
                    console.log(`[TRACK] Parsed response data:`, data);

                    if (data.success && data.track) {
                        console.log(`[TRACK] Updating now playing to: ${data.track}`);
                        updateNowPlaying(nowPlaying, data.track, true);
                    } else if (data.success) {
                        console.log(`[TRACK] Track changed but no track info available`);
                        // Keep showing loading state and current track while we wait for polling to update
                        const playButton = deviceCard.querySelector('.play-button');
                        if (playButton) {
                            updateButtonState(playButton, 'PLAYING');
                        }
                    } else {
                        console.warn(`[TRACK] Track control failed:`, data.error);
                        updateNowPlaying(nowPlaying, currentTrack, wasPlaying);
                    }
                } catch (parseError) {
                    console.error(`[TRACK] JSON parse error:`, parseError);
                    console.error(`[TRACK] Failed to parse:`, text);
                    updateNowPlaying(nowPlaying, currentTrack, wasPlaying);
                }
            } catch (error) {
                console.error('[TRACK] Error controlling track:', error);
                updateNowPlaying(nowPlaying, currentTrack, wasPlaying);
            } finally {
                buttons.forEach(btn => btn.disabled = false);
                nowPlaying.classList.remove('loading');
                console.log(`[TRACK] Re-enabled track control buttons and removed loading state`);
            }
        }

        /**
         * Controls the volume for all devices in a group
         * @param {string} ip - The device IP address
         * @param {string} action - The volume action ('up', 'down', or 'mean')
         */
        async function controlGroupVolume(ip, action) {
            const deviceCard = document.querySelector(`.device-card[data-ip="${ip}"]`);
            const buttons = deviceCard.querySelectorAll('.group-volume-control .volume-button');
            const groupMembers = deviceCard.querySelectorAll('.device-details .group-device');

            console.log(`[GROUP VOLUME] Starting group volume control for ${ip}, action: ${action}`);
            console.log(`[GROUP VOLUME] Found ${groupMembers.length} group members`);

            // Disable all volume controls in the group
            buttons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
            });

            // Also disable individual volume controls for all members
            groupMembers.forEach(member => {
                const memberIp = member.dataset.ip;
                if (memberIp) {
                    const controls = member.querySelectorAll('button');
                    controls.forEach(control => {
                        control.disabled = true;
                        control.style.opacity = '0.5';
                    });
                }
            });

            try {
                const response = await fetch(`/api/group/volume/${ip}/${action}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                const data = await response.json();
                console.log(`[GROUP VOLUME] Response:`, data);

                if (data.success && data.results) {
                    console.log(`[GROUP VOLUME] Success, updating volumes for ${data.results.length} devices`);
                    // Update volume displays for each device that changed
                    data.results.forEach(result => {
                        const volumeButtons = document.querySelectorAll(`[data-ip="${result.ip}"] .volume-text, .volume-text[data-ip="${result.ip}"]`);
                        volumeButtons.forEach(button => {
                            button.textContent = `${result.volume}%`;
                            console.log(`[GROUP VOLUME] Updated volume for ${result.ip} to ${result.volume}%`);
                        });
                    });
                } else {
                    console.error('[GROUP VOLUME] Failed:', data.error || 'Unknown error');
                }
            } catch (error) {
                console.error('[GROUP VOLUME] Error controlling group volume:', error);
            } finally {
                // Re-enable all controls
                buttons.forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                });

                groupMembers.forEach(member => {
                    const memberIp = member.dataset.ip;
                    if (memberIp) {
                        const controls = member.querySelectorAll('button');
                        controls.forEach(control => {
                            control.disabled = false;
                            control.style.opacity = '1';
                        });
                    }
                });
            }
        }

        function toggleTheme() {
            const html = document.documentElement;
            const themeToggle = document.querySelector('.theme-toggle');
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';

            html.setAttribute('data-theme', newTheme);
            themeToggle.setAttribute('data-theme', newTheme);

            // Save theme preference
            localStorage.setItem('theme', newTheme);
        }

        /**
         * Shows the loading overlay
         */
        function showLoadingOverlay() {
            const overlay = document.querySelector('.loading-overlay');
            overlay.classList.remove('hidden');
        }

        /**
         * Hides the loading overlay
         */
        function hideLoadingOverlay() {
            const overlay = document.querySelector('.loading-overlay');
            overlay.classList.add('hidden');
        }

        // Modify the refresh button to show loading state
        document.addEventListener('DOMContentLoaded', () => {
            const refreshButton = document.querySelector('.refresh-button');
            refreshButton.onclick = (e) => {
                e.preventDefault();
                const overlay = document.querySelector('.loading-overlay');
                overlay.classList.remove('hidden');
                setTimeout(() => {
                    window.location.reload();
                }, 100);
            };

            // Rest of your existing DOMContentLoaded code...
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);

            const themeToggle = document.querySelector('.theme-toggle');
            themeToggle.setAttribute('data-theme', savedTheme);

            const devices = document.querySelectorAll('.device-card');
            const loadingPromises = [];

            devices.forEach(device => {
                const ip = device.dataset.ip;
                const playButton = device.querySelector('.play-button');
                const volumeTexts = device.querySelectorAll('.volume-text');
                const isGroup = device.hasAttribute('data-is-group');

                device.addEventListener('click', handleCardClick);
                if (playButton) {
                    startPollingDevice(ip, playButton);
                }

                // Add click handlers for volume text mute/unmute
                volumeTexts.forEach(volumeText => {
                    volumeText.title = 'Click to mute';
                    volumeText.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent card expansion
                        toggleMute(volumeText.dataset.ip || ip, volumeText);
                    });
                });

                // For group cards, update volumes for all members
                if (isGroup) {
                    const groupMembers = device.querySelectorAll('.group-device');
                    groupMembers.forEach(member => {
                        const memberIp = member.dataset.ip;
                        if (memberIp) {
                            loadingPromises.push(updateVolumeDisplay(memberIp));
                        }
                    });
                } else {
                    // Add volume display promise for individual device
                    loadingPromises.push(updateVolumeDisplay(ip));
                }
            });

            // Wait for all loading promises to complete before hiding overlay
            Promise.all(loadingPromises)
                .finally(() => {
                    setTimeout(hideLoadingOverlay, 800);
                });
        });

        // Show loading overlay on page unload (refresh/navigation)
        window.addEventListener('beforeunload', () => {
            const overlay = document.querySelector('.loading-overlay');
            overlay.classList.remove('hidden');
        });

        async function toggleMute(ip, button) {
            console.log(`[MUTE] Attempting to toggle mute for IP ${ip}`);
            const isMuted = button.classList.contains('muted');
            const action = isMuted ? 'unmute' : 'mute';

            // Disable the button and show loading state
            button.disabled = true;
            button.style.opacity = '0.5';

            try {
                console.log(`[MUTE] Sending ${action} request to /api/volume/${ip}/${action}`);
                const response = await fetch(`/api/volume/${ip}/${action}`);
                console.log(`[MUTE] Response status: ${response.status}`);

                if (!response.ok) {
                    console.error(`[MUTE] HTTP error: ${response.status}`);
                    return;
                }

                const data = await response.json();
                console.log(`[MUTE] Response data:`, data);

                if (data.success) {
                    // Update all volume displays for this device
                    const volumeButtons = document.querySelectorAll(`.volume-control[data-ip="${ip}"] .volume-text, .device-card[data-ip="${ip}"] .volume-text`);
                    console.log(`[MUTE] Found ${volumeButtons.length} volume buttons to update`);

                    volumeButtons.forEach(btn => {
                        btn.classList.toggle('muted', !isMuted);
                        btn.title = !isMuted ? 'Click to unmute' : 'Click to mute';
                    });
                } else {
                    console.error(`[MUTE] API returned error:`, data.error);
                }
            } catch (error) {
                console.error('[MUTE] Error toggling mute:', error);
            } finally {
                // Re-enable the button and restore opacity
                button.disabled = false;
                button.style.opacity = '1';
            }
        }
    </script>
    </body>
</html>
